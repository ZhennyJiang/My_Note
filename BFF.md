# BFF（Backend For Frontend）初步方案

## 一、背景与目标

1. **背景**  
   - 公司目前有两个主要前端：PC 端（Web）和 App 端（iOS / Android）。  
   - 后端由多个服务或微服务提供接口，供 PC、App 等客户端调用。  
   - 现状问题：
     - 前端需要与多个后端服务直接对接，代码中存在大量对后端接口的调用和数据处理逻辑。
     - 不同前端的业务需求和接口需求不尽相同，但很多与后端对接的逻辑高度重复或存在冗余。
     - 在后端接口版本变化时，可能需要频繁修改前端代码，维护成本高。

2. **目标**  
   - 在前端与后端之间增加一层 **BFF（Backend For Frontend）**，专门为各前端（PC、App）提供与其需求相匹配的接口。
   - 减轻前端直接调用多个后端服务带来的复杂度；统一处理鉴权、聚合、数据处理、缓存、降级等逻辑。
   - 通过对前端需求的适配，减少对前端的侵入性修改，同时减轻对后端 API 的不必要依赖。
   - 为今后扩展更多前端形态（例如小程序、IoT 设备等）做好准备，形成可复用的基础能力。



---

## 二、多端BFF和单一BFF

### 1. 多端 BFF 与单一 BFF 的区别

1. **单一 BFF（One BFF）**
   - **特点**：只有一个 BFF 服务实例，所有前端（PC、移动端、小程序等）都请求这一服务。
   - **优点**：
     - 开发部署相对简单，只需维护一个 BFF 应用。
     - 公共逻辑（鉴权、日志、监控、降级、缓存等）可在同一个服务里复用。
     - 在初期业务尚不复杂时，能快速落地，团队学习成本较低。
   - **缺点**：
     - 不同端的业务需求、接口格式都挤在同一个代码仓库里，需要通过路由或中间件来区分。
     - 随着业务规模扩大，单一 BFF 代码量易增多，维护成本逐渐升高。
     - 如果某一端进行大规模改动，可能会影响到其他端的开发 / 部署节奏。
2. **多端 BFF（Multiple BFFs）**
   - **特点**：为不同客户端（PC、App、第三方等）分别部署独立的 BFF 应用，或者按业务类型拆分多个 BFF。
   - **优点**：
     - 每个 BFF 面向特定端或特定业务场景，接口设计更灵活、针对性更强。
     - 不同 BFF 互不干扰，部署和迭代可以独立进行。
     - 维护成本在代码结构层面更清晰，不同团队可以各自负责对应 BFF。
   - **缺点**：
     - 对团队和运维提出更高要求，需要有多套服务部署、监控、日志等基础能力。
     - 公共逻辑需要在多个 BFF 中重复实现或抽象到公共库/网关，否则会有重复劳动。
     - 初期如果业务量小，而团队人手有限，可能会增加额外的管理开销。

------

### 2、结合我司B2B 交易系统的特点进行考量

1. **B2B 平台多以桌面端为主，但移动端也可能快速增长**
   - 如果现阶段 PC 端的用户量和功能需求远大于移动端，并且移动端的功能相对简单，就不一定需要单独做一个 BFF 来服务移动端。
   - 若移动端需求与 PC 端高度重叠（如业务流程、接口字段等），单一 BFF 通过路由或鉴权区分客户端即可满足需求。
   - 但若移动端需要的接口与 PC 端差异化很大，比如需要更轻量化的接口、不同的数据返回格式、不同的缓存策略，则可以考虑单独维护一个 App BFF。
2. **B2B 系统的接口复杂度和数据安全要求较高**
   - 由于 B2B 交易通常涉及供应链、报价、订单、支付等较为复杂的环节，对数据安全、访问权限、审计日志的要求也会更高。
   - 单一 BFF 有一个好处：只需要在这一个服务里做好鉴权、日志、审计、数据加解密等功能，所有端都统一使用这一套逻辑。
   - 如果拆分成多个 BFF，就需要在每个 BFF 都实现类似的权限管理、安全策略和审计机制，或额外在网关层处理。
3. **团队规模和后续演进**
   - 由于我司的前端、后端团队规模都不大，而且大家目前都是在摸索 BFF 这条路，**单一 BFF** 会是一个较优的起点。
     - 只有 PC + App 两个端，且尚未形成非常庞大的业务场景，单一 BFF 的架构简单、易落地。
     - 大家可以先在 BFF 层沉淀出统一的中间件、日志、鉴权、缓存等基础能力。
   - 等到后续业务规模扩大，或者产生了更多独立业务线时，可以再把某些高度定制化的场景从单一 BFF 中拆分出去，变成多端/多业务 BFF，形成更细粒度的服务拆分。
4. **运维成本与部署方式**
   - 维护多个 BFF 意味着要多维护一套 CICD、日志监控、报警策略、API 网关配置等。若目前团队中并没有成熟的 DevOps 能力，或者还没来得及搭建完善的监控/告警体系，建议以单一 BFF 先行落地。
   - 如果我司对微服务和 DevOps 的支持已经相对完善，而且 BFF 所需的基础能力可以通过公共库或公共中间件共享，那么多端 BFF 的运维成本会降低，也可以考虑一开始就独立部署多个 BFF。

------

### 3、综合建议

1. **初期推荐使用单一 BFF**
   - 我司目前是一个 B2B 交易系统，只有 PC 和 App 两个客户端，而且团队对 BFF 都是新手。
   - 使用单一 BFF 可以尽快建立起 BFF 的开发、部署、运维、监控等体系，同时让前端和后端团队逐步熟悉 BFF 的价值和工作流程。
2. **在代码层面区分 PC 与移动端逻辑**
   - 即使在一个 BFF 项目中，也可以通过文件夹、路由配置的方式把 PC 和 App 的接口分开，例如：
     - `routes/pc/**` 存放 PC 端接口
     - `routes/app/**` 存放 App 端接口
   - 中间件层、服务调用层的通用逻辑可以沉淀到公共模块，避免重复开发。
3. **后续逐步演进到多 BFF**
   - 当遇到以下情境，可再考虑把单一 BFF 拆分：
     - PC 与移动端对后端接口的要求和演进速度差异巨大，频繁在同一个 BFF 仓库改动造成协作混乱。
     - 需要为外部合作伙伴或其他第三方提供定制化接口，差异度很高。
     - 团队规模扩大，开发和运维能力能够支撑多服务的模式。
   - 拆分后，每个 BFF 服务面向不同需求和端，开发节奏和版本发布可彼此独立，运维也更灵活。

------

### 4、总结

- **B2B 交易系统场景下，若只有 PC 端和 App 端，且团队刚开始尝试 BFF**：建议先使用**单一 BFF**落地；将公共逻辑统一在同一个服务里，通过代码分层来区分不同终端的接口和数据处理需求。
- **后续随着业务扩张、端数增多或需求分化**：可以再将单一 BFF 的代码和服务逐步拆分为多个，更精细地服务不同前端或不同业务线。
- BFF 要为业务提效并减小负担，而不是一上来就把架构做得过于复杂。先做轻量化、可演进的方案最为稳妥。



---

## 三、BFF 整体架构设计

### 2.1 架构示意

![image-20250328090546383](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250328090546383.png

![image-20250331151708862](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250331151708862.png)

- **PC 端 BFF**：专门为 Web PC 客户端提供接口。对 Web 相关的需求进行业务聚合、数据加工和输出。  
- **App 端 BFF**：为移动 App 客户端提供接口，处理 App 特有需求，同时可重用一些公共逻辑。  
- **后端服务**：原有的后端服务提供核心业务逻辑、数据存储和服务能力。BFF 层调用这些后端服务并进行业务数据处理后再返回给各前端。

> 注：刚开始使用 BFF，往往会先建一个 BFF 应用，内部根据请求头、路由等方式区分来自 PC 还是 App，然后提供不同的路由处理和接口返回。随着团队和业务规模的增长，也可拆分为多个独立的 BFF 项目。

### 2.2 模块拆分思路

1. **网关层（可选）**  
   - 有些公司会在 BFF 之前再放一个网关（API Gateway），用于统一入口、权限校验、灰度发布、流量控制、日志收集等。
   - 如果当前需求不复杂，BFF 本身就可以承担鉴权、路由转发等工作，暂时无需单独的网关层。

2. **BFF 核心功能**  
   - **路由与接口定义**：对外暴露统一的 HTTP 接口（RESTful 或 GraphQL 形式）；根据请求路径或参数区分不同的业务逻辑。
   - **业务聚合**：需要从多个后端服务获取数据或调用不同的接口时，可以在 BFF 中统一完成聚合逻辑，减少前端的多次请求。
   - **数据转换**：根据 PC / App 的需求对数据结构和格式进行转换、裁剪或组合。
   - **权限 / 鉴权**：在 BFF 层增加对接公司统一的认证授权（如 Token、Session、OAuth2 等），或二次鉴权逻辑。
   - **缓存策略**：对某些请求的结果进行短期缓存，降低后端压力，提高前端响应速度。
   - **降级与熔断**：如果某些后端服务宕机或者网络异常，通过 BFF 进行服务降级、熔断。
   - **监控与日志**：记录访问日志、错误日志，并进行监控告警。

3. **后端服务调用**  
   - BFF 通过 SDK 或者 HTTP / RPC 调用具体后端服务接口，获取业务数据后进行处理。
   - 后续可与后端团队一起优化接口设计、抽象可复用的方法等。

---

## 四、技术栈与框架选型

### 3.1 后端运行环境与语言

1. **Node.js**  
   - 前端团队熟悉 JavaScript / TypeScript，转到 Node.js 进行 BFF 开发门槛相对较低。
   - 可用的框架有 [Express](https://expressjs.com/)、[Koa](https://koajs.com/) 或 [NestJS](https://nestjs.com/) 等。
   - 在 Node.js 环境下可以共享部分工具库、数据验证库，以及更容易与前端同学协作。

2. **Java / Go / Python**  
   - 如果公司后端多使用 Java/Go/Python，也可以在对应语言里开发 BFF 层。
   - 但由于 BFF 通常更贴近前端需求，如果前端团队主导，使用 Node.js / TypeScript 会是更常见的选择。

### 3.2 接口风格

1. **RESTful API**  
   - 更常见、易于理解。
   - 如果仅仅是初步接入，RESTful 即可满足需求。

2. **GraphQL**（可考虑）  
   - 能够让前端自定义请求数据结构并返回所需字段，避免冗余数据传输。
   - 在业务复杂、前后端交互字段多变时会有显著优势。
   - 但对团队有一定学习成本，需建立 GraphQL Server，并配合一些缓存策略、Schema 设计等。

### 3.3 数据传输与格式

- BFF 层的入参和出参可以统一使用 JSON。
- 如公司业务有特殊需求，也可选择加密或者自定义序列化方式，但一般 JSON + HTTPS 就能满足大多数场景。

---

## 五、BFF 实现要点与示例

以下以 **Node.js + Koa（或 Express）** 结合 TypeScript 进行示例说明，重点关注通用的实现思路：

1. **项目结构示例**  
   ![image-20250328090613120](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250328090613120.png)

2. **路由层**  
- 区分 PC 端路由和 App 端路由：  
  ```typescript
  // routes/pc/user.ts (以 Koa 为例)
  import Router from 'koa-router';
  const router = new Router();

  router.get('/user/info', async (ctx) => {
    // 调用后端服务
    const userInfo = await userService.getUserInfo(ctx.query.userId);
    // 针对 PC 端做数据格式转换
    ctx.body = formatUserForPC(userInfo);
  });

  export default router;
  ```

  ```typescript
  // routes/app/user.ts
  import Router from 'koa-router';
  const router = new Router();

  router.get('/user/info', async (ctx) => {
    const userInfo = await userService.getUserInfo(ctx.query.userId);
    // 针对 App 端做数据格式转换
    ctx.body = formatUserForApp(userInfo);
  });

  export default router;
  ```

3. **业务服务调用（services）**  
- 封装后端接口：例如 `userService.ts` 用于封装对 “用户后端服务” 的调用。
- 可以通过 `axios`、`fetch` 或公司内部封装好的 HTTP / RPC 调用工具与后端通信。
- 建议在这里统一处理请求头、鉴权 Token、错误处理、重试等逻辑。

4. **中间件**  
- **鉴权**：在请求到达路由之前校验用户 Token 是否有效；区分是否来自 PC / App；如果需要登录态，跳转或返回 401。
- **异常处理**：拦截服务调用或业务逻辑中的异常，返回统一的错误格式，便于客户端处理或显示。
- **日志**：收集接口访问、错误日志、耗时等信息，必要时可配置 ELK 或其他日志采集平台。

5. **数据格式与校验**  
- 使用 `class-validator`、`Joi` 等库对请求入参进行校验。
- 确保 BFF 输入参数合法，输出给前端的数据结构清晰稳定。

6. **缓存与降级**  
- 可针对一些读频繁、写较少的接口做内存缓存或使用 Redis 缓存。
- 如果调用后端服务超时或出现错误，可以在 BFF 返回默认值或进行降级逻辑，保证前端可用性。

---

## 五、开发流程与协作

1. **需求梳理**  
- 与 PC 前端、App 前端、后端团队确认业务需求和接口需求。
- 列出各前端需要的数据字段和交互方式，是否存在重复或可抽象出的共性逻辑。

2. **API 设计**  
- 为 PC 和 App 端分别设计契合其需求的接口。
- 如果可以复用，则公共部分可放在同一接口中，不同端通过请求参数区分；或者单独写两个路由，但调用相同的内部服务逻辑。

3. **后端服务配合**  
- 与后端团队沟通数据结构和接口约定，协商是否需要增加或调整后端接口。
- 明确 BFF 与后端之间的鉴权方式、错误码等细节。

4. **BFF 开发与测试**  
- 按照业务模块拆分进行开发，先实现公共功能（中间件、日志、鉴权等），再开发具体路由、服务调用。
- 接口联调时，可使用 Postman / Swagger / 内网工具进行测试。
- 配合前端（PC / App）进行测试，检查返回结果是否符合预期。

5. **上线发布**  
- 建立持续集成（CI）和持续部署（CD）流程，自动化打包测试、推送到测试环境和生产环境。
- 配置监控和告警，观察 BFF 的访问量、错误率、性能指标。

---

## 六、后续优化与扩展

1. **GraphQL 或多 BFF 服务**  
- 当业务需求变得更复杂，可考虑 GraphQL 做更灵活的数据获取。
- 当团队规模扩大、需求增多，可以拆分为 Web BFF、App BFF、第三方接口 BFF 等不同服务独立维护。

2. **微前端与多端复用**  
- 随着 PC、App、小程序等前端形态的增多，可在 BFF 内进一步抽象公共服务，减少重复代码。
- 考虑在 BFF 层做更多统一处理（国际化、多语言、多主题等）。

3. **安全与运维**  
- 加强对 BFF 的安全防护，包括防止注入、CSRF、XSS 等；对数据加密、敏感信息脱敏。
- 监控、日志分析平台，以及自动化横向扩容、容器化部署（Docker/Kubernetes）。

4. **性能优化**  
- 对高并发场景可使用负载均衡或水平扩展 BFF 服务实例。
- 针对慢接口进行压测，优化后端请求合并、异步处理、缓存策略等。

---

## 七、总结

- **BFF 的核心价值**：它将前端需求与后端服务解耦，前端团队只需要与 BFF 沟通，BFF 内部统一调用并聚合后端服务。
- **公司刚起步**：可先在单个 BFF 项目中区分不同的路由、逻辑，如果未来业务增大，再拆分多个 BFF 服务。
- **关键点**：
1. 选定一个主流框架（Node.js + Koa/Express/NestJS）。
2. 规划统一的目录结构，并将业务逻辑抽象到 services 层。
3. 建立基础中间件和通用模块（鉴权、日志、监控、异常处理、数据校验）。
4. 梳理前端需求，精简接口和字段，让 BFF 为 PC、App 各自返回优化后的数据结构。
5. 持续关注性能和监控，以数据驱动后续的优化。



## 八、个人观点

采用单一BFF和GraghQL

![image-20250331160114034](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250331160114034.png)

